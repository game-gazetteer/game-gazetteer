<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Game Gazetteer - Metroid Prime 4: Beyond</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2231351762568545"
     crossorigin="anonymous">
  </script>
  <style>

    /* ===== MAP PIN MARKER ===== */
    .marker {
    position: relative;
    width: 34px;
    height: 34px;
    background: #673ab7;
    border-radius: 50% 50% 50% 0;
    transform: rotate(-45deg);
    box-shadow: 0 4px 10px rgba(0,0,0,0.45);
    border: 2px solid rgba(255,255,255,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    }

    /* Locked state: red outline (only used in edit mode via JS) */
    .marker-locked {
      border-color: rgba(255, 0, 0, 0.95) !important;
    }

    /* SVG icon */
    .marker svg {
        width: 100%;
        height: 100%;
        fill: white;
        z-index: 2;
    }

    /* Found state */
    .marker-found {
    opacity: 0.5;
    filter: grayscale(60%);
    }

    /* Category colors */
    .marker-crystals       { background: blue; }
    .marker-hearts         { background: red; }
    .marker-tapes          { background: green; }
    .marker-keys           { background: cyan; }
    .marker-walls          { background: purple; }
    .marker-npc            { background: #ff7043; }
    .marker-secrets        { background: rgb(60, 0, 128); }

    .leaflet-container img.leaflet-tile {
        mix-blend-mode: normal;
        width: 256px !important;
        height: 256px !important;
    }

    /* Remove the default popup close button */
    .leaflet-popup-close-button {
    display: none;
    }

    /* Dark mode popup styles */
    .popup-dark .leaflet-popup-content-wrapper {
    background: rgba(30,30,30,0.95) !important;
    color: #ddd;
    border-radius: 8px;
    box-shadow: none;
    border: none;
    }

    .popup-dark .leaflet-popup-tip {
    background: rgba(30,30,30,0.95) !important;
    border: none;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", sans-serif;
    }

    #map { 
      width: 100%; height: 100%; 
      background: #01090c;
    }

    /* SIDEBAR */
    #controls {
      position: absolute;
      top: 60px; /* moved down from 20px */
      left: 20px;
      width: 260px;
      max-height: calc(100vh - 80px);
      background: rgba(20,20,20,0.85);
      color: #eee;
      padding: 18px;
      border-radius: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 2000;
      display: block;

      overflow-y: auto;  /* enable vertical scrolling */
      scrollbar-width: thin; /* for Firefox */
      scrollbar-color: rgba(255,255,255,0.3) transparent;
    }

    #controls::-webkit-scrollbar {
      width: 8px;
    }

    #controls::-webkit-scrollbar-thumb {
      background-color: rgba(255,255,255,0.3);
      border-radius: 4px;
    }

    #controls::-webkit-scrollbar-track {
      background: transparent;
    }

    /* SIDEBAR TOGGLE */
    #toggleSidebar {
      position: absolute;
      top: 20px; /* stays above the sidebar */
      left: 20px;
      z-index: 3000;
      background: rgba(20,20,20,0.85);
      border: none;
      padding: 6px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #toggleSidebar svg {
    display: block;
    }

    #controls h2 {
      margin: 0 0 12px;
      font-size: 20px;
      font-weight: 600;
    }

    .subcategory { margin-top: 14px; }

    .subcategory h3 {
      margin: 0 0 8px;
      font-size: 15px;
      font-weight: 600;
      color: #fff;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
    }

    .filter-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(255,255,255,0.05);
      padding: 6px 8px;
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .filter-item:hover {
      background: rgba(255,255,255,0.12);
    }

    .filter-icon {
      width: 22px;
      height: 22px;
      fill: white;
      flex-shrink: 0;
    }

    .filter-item span {
      flex-grow: 1;
      margin-left: 10px;
      font-size: 14px;
    }

    /* Toggle Switch (sidebar) */
    .filter-item input[type="checkbox"] {
      appearance: none;
      width: 36px;
      height: 18px;
      background: #555;
      border-radius: 9px;
      position: relative;
      cursor: pointer;
      outline: none;
      transition: 0.2s;
    }
    .filter-item input[type="checkbox"]::after {
      content: "";
      width: 14px;
      height: 14px;
      background: #ccc;
      position: absolute;
      top: 2px;
      left: 2px;
      border-radius: 50%;
      transition: 0.2s;
    }
    .filter-item input[type="checkbox"]:checked {
      background: #4caf50;
    }
    .filter-item input[type="checkbox"]:checked::after {
      left: 20px;
      background: white;
    }

    #foundToggle {
      margin-top: 18px;
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: #673ab7;
      color: white;
      font-size: 14px;
    }

    #progressBox {
      background: rgba(255,255,255,0.08);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
    }

    #progressBox h3 {
      margin: 0 0 6px;
      font-size: 16px;
      color: #fff;
    }

    #progressDetails {
      font-size: 14px;
      opacity: 0.9;
    }

    #progressDetailsContainer.centered {
      justify-content: center; /* center the text when star is hidden */
    }

    /* Progress bar container */
    #progressBarOuter {
      width: 100%;
      height: 14px;
      background: rgba(255,255,255,0.15);
      border-radius: 8px;
      overflow: hidden;
      margin: 8px 0 10px 0;
    }

    /* Animated filling bar */
    #progressBarInner {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #9c7cff, #673ab7);
      transition: width 0.35s ease;
      border-radius: 8px;
    }

    #progressStar {
      font-size: 20px;
      filter: drop-shadow(0 0 4px gold);
      display: inline-block; /* will toggle to none in JS */
      transition: transform 0.4s cubic-bezier(.3,1.5,.7,1);
    }

    /* Popup toggle switch */
    .popup-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 6px;
    }
    .popup-toggle input[type="checkbox"] {
      appearance: none;
      width: 28px;
      height: 14px;
      background: #555;
      border-radius: 7px;
      position: relative;
      cursor: pointer;
      outline: none;
      transition: 0.2s;
    }
    .popup-toggle input[type="checkbox"]::after {
      content: "";
      width: 12px;
      height: 12px;
      background: #2196F3; /* blue toggle */
      position: absolute;
      top: 1px;
      left: 1px;
      border-radius: 50%;
      transition: 0.2s;
    }
    .popup-toggle input[type="checkbox"]:checked {
      background: #2196F3;
    }
    .popup-toggle input[type="checkbox"]:checked::after {
      left: 15px;
      background: white;
    }

    .collapsible-header {
      cursor: pointer;
      user-select: none;
      position: relative;
    }

    .subcategory-content {
      overflow: hidden;
      max-height: 500px;
      transition: max-height 0.25s ease;
    }

    .subcategory.collapsed .subcategory-content {
      max-height: 0;
    }

    /* ------------------------------
      MOBILE RESPONSIVE SIDEBAR
    --------------------------------*/
    @media (max-width: 768px) {
      #controls {
        width: 70%;             /* shrinks sidebar */
        left: 10px;
        top: 70px;
        padding: 14px;
        border-radius: 12px;
        font-size: 14px;
      }

      #toggleSidebar {
        top: 10px;
        left: 10px;
        padding: 6px;
        transform: scale(0.9);
      }

      #controls h2 {
        font-size: 18px;
      }

      .subcategory h3 {
        font-size: 14px;
      }

      .filter-item span {
        font-size: 13px;
      }

      .filter-item {
        padding: 4px 6px;
      }

      #foundToggle,
      #resetProgress,
      #showAllBtn,
      #hideAllBtn {
        font-size: 13px;
        padding: 8px;
      }

      #markerSearch {
        font-size: 13px;
      }
    }

    /* Extra small screens (phones in portrait) */
    @media (max-width: 480px) {
      #controls {
        width: 85%;
        padding: 12px;
        left: 8px;
        top: 65px;
      }

      #toggleSidebar {
        transform: scale(0.8);
      }

      .filter-item {
        padding: 4px 5px;
      }
    }

  </style>
</head>

<body>

<button id="toggleSidebar" title="Toggle Sidebar">
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="3" y1="6" x2="21" y2="6"/>
    <line x1="3" y1="12" x2="21" y2="12"/>
    <line x1="3" y1="18" x2="21" y2="18"/>
  </svg>
</button> 

<div id="controls">

  <a href="https://www.gamegazetteer.com" id="gazetteerBtn" style="
    display: flex;
    align-items: center;
    gap: 10px;
    text-decoration: none;
    color: white;
    padding: 4px 0px;
    border-radius: 8px;
    font-weight: 600;
    margin-bottom: 10px;
    font-size: 28px;
    font-family: 'Cinzel', serif;
  ">
    <img src="favicon.png" alt="Logo" style="width:32px; height:32px;">
    Game Gazetteer
  </a>



  <input type="text" id="markerSearch" placeholder="Search..." style="
    width: calc(100% - 16px);
    padding: 6px 8px;
    border-radius: 6px;
    border: none;
    outline: none;
    font-size: 14px;
    margin-bottom: 10px;
    display: block;
  ">

  <div id="toggleAllContainer" style="display:flex; gap:8px; margin-top:10px;">
      <button id="showAllBtn" style="
          flex:1;
          padding:8px;
          border:none;
          border-radius:8px;
          cursor:pointer;
          background: #673ab7;  /* same purple */
          color:white;
          font-size:14px;
      ">Show All</button>

      <button id="hideAllBtn" style="
          flex:1;
          padding:8px;
          border:none;
          border-radius:8px;
          cursor:pointer;
          background: #673ab7;  /* same purple */
          color:white;
          font-size:14px;
      ">Hide All</button>
  </div>

  <!-- COLLECTIBLES -->
  <div class="subcategory">
    <h3 class="collapsible-header">Collectibles</h3>
      <div class="subcategory-content">
        <label class="filter-item">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 64 64"
            width="28"
            height="28"
            fill="none"
            stroke="currentColor"
            stroke-width="2.5"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <!-- Outer crystal -->
            <polygon points="32,4 52,22 40,58 24,58 12,22" />

            <!-- Inner facets -->
            <line x1="32" y1="4" x2="32" y2="58" />
            <line x1="32" y1="4" x2="40" y2="24" />
            <line x1="32" y1="4" x2="24" y2="24" />
          </svg>

          <span>Green Energy Crystals</span>
          <input type="checkbox" class="category" value="crystals" checked>
        </label>

        <label class="filter-item">
          <svg class="filter-icon" viewBox="0 0 24 24">
            <path
              d="M12 20
                C12 20 4 13.5 4 8.5
                C4 6 6 4 8.5 4
                C10.5 4 12 5.5 12 5.5
                C12 5.5 13.5 4 15.5 4
                C18 4 20 6 20 8.5
                C20 13.5 12 20 12 20Z"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span>Crystal Hearts</span>
          <input type="checkbox" class="category" value="hearts" checked>
        </label>

        <label class="filter-item">
          <svg class="filter-icon" viewBox="0 0 24 24" aria-label="Cassette tape">
            <rect
              x="3"
              y="5"
              width="18"
              height="14"
              rx="2"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            />

            <rect
              x="6"
              y="7"
              width="12"
              height="4"
              rx="1"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
            />

            <circle
              cx="8.5"
              cy="14"
              r="2"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
            />

            <circle
              cx="15.5"
              cy="14"
              r="2"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
            />

            <line
              x1="10.5"
              y1="14"
              x2="13.5"
              y2="14"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
            />
          </svg>
          <span>Cassettes</span>
          <input type="checkbox" class="category" value="tapes" checked>
        </label>

        <label class="filter-item">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 64 64"
            width="28"
            height="28"
            aria-label="Key"
          >
            <!-- Key head -->
            <circle
              cx="20"
              cy="32"
              r="12"
              fill="none"
              stroke="white"
              stroke-width="4"
            />

            <!-- Head hole -->
            <circle
              cx="20"
              cy="32"
              r="4"
              fill="none"
              stroke="white"
              stroke-width="3"
            />

            <!-- Shaft -->
            <rect
              x="32"
              y="28"
              width="20"
              height="8"
              fill="white"
            />

            <!-- Teeth -->
            <rect x="46" y="36" width="6" height="8" fill="white"/>
            <rect x="38" y="36" width="6" height="5" fill="white"/>
          </svg>
          <span>Keys/Locks</span>
          <input type="checkbox" class="category" value="keys" checked>
        </label>

      </div>
  </div>

  <!-- POINTS OF INTEREST -->
  <div class="subcategory">
    <h3 class="collapsible-header">Points of Interest</h3>
      <div class="subcategory-content">

        <label class="filter-item">
          <svg class="filter-icon" viewBox="0 0 24 24"><path d="M12 2a5 5 0 1 1 0 10 5 5 0 0 1 0-10zm0 12c-4 0-8 2-8 6v2h16v-2c0-4-4-6-8-6z"/></svg>
          <span>NPCs</span>
          <input type="checkbox" class="category" value="NPC" checked>
        </label>

        <label class="filter-item">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 64 64"
            width="24"
            height="24"
            fill="none"
            stroke="currentColor"
            stroke-width="3"
            stroke-linecap="round"
            stroke-linejoin="round"
            aria-label="Smashable wall icon"
          >
            <rect x="10" y="12" width="44" height="40" rx="4"/>

            <path d="M12 24H52"/>
            <path d="M12 36H52"/>
            <path d="M12 48H52"/>

            <path d="M22 12V24"/>
            <path d="M42 12V24"/>
            <path d="M16 24V36"/>
            <path d="M32 24V36"/>
            <path d="M48 24V36"/>
            <path d="M22 36V48"/>
            <path d="M42 36V48"/>
            <path d="M16 48V52"/>
            <path d="M32 48V52"/>
            <path d="M48 48V52"/>

            <path d="M34 16
                    L30 22
                    L36 28
                    L28 34
                    L34 40
                    L26 48" />

            <path d="M46 30 L50 28"/>
            <path d="M44 44 L48 46"/>
          </svg>
          <span>Smashable Walls</span>
          <input type="checkbox" class="category" value="walls" checked>
        </label>

        <label class="filter-item">
          <svg class="filter-icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="
              M12 2
              C8.7 2, 6.2 4.1, 6.2 7
              H8.6
              C8.6 5.4, 9.9 4.4, 12 4.4
              C14 4.4, 15.4 5.5, 15.4 7.2
              C15.4 8.7, 14.4 9.5, 12.9 10.4
              C11.2 11.4, 10.6 12.3, 10.6 14
              V15.2
              H13
              V14.4
              C13 13.2, 13.6 12.7, 15.2 11.7
              C17 10.6, 18 9.3, 18 7.1
              C18 4.2, 15.3 2, 12 2
              Z
            "/>
            <circle cx="12" cy="18.5" r="1.6"/>
          </svg>
          <span>Secrets</span>
          <input type="checkbox" class="category" value="secrets" checked>
        </label>
      </div>
  </div>

  <!-- PROGRESS COUNTER (moved to bottom) -->
  <div id="progressBox">
    <h3>Progress</h3>

    <div id="progressBarOuter">
      <div id="progressBarInner"></div>
    </div>

    <div id="progressDetailsContainer" style="display:flex; align-items:center; justify-content:center; gap:6px; margin-top:4px;">
      <div id="progressDetails">0 / 0 (0%)</div>
      <div id="progressStar">‚≠ê</div>
    </div>

  </div>

  <button id="foundToggle">Hide Found Items</button>

  <button id="resetProgress" style="
    margin-top: 10px;
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background: #e53935; /* red */
    color: white;
    font-size: 14px;
  ">Reset Progress</button>

</div>

<div id="map"></div>

<button id="exportMarkers" style="
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 99999;
  padding: 10px 14px;
  border-radius: 10px;
  background: #673ab7;
  color: white;
  border: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: none;
">
  Export Marker JSON
</button>


<select id="layerSelect" style="
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 3000;

  padding: 6px 14px;
  border-radius: 10px;
  background: rgba(20,20,20,0.85);
  color: white;
  border: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
">
  <option value="viewros">Viewros</option>
</select>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
const forcedVisibleMarkers = new Set();

// ============================
// EDIT MODE GLOBALS
// Use: ?edit=true
// ============================
window.GG_EDIT_MODE = new URLSearchParams(window.location.search).get("edit") === "true";

// This will hold the raw JSON array (metroid-prime-4-markers.json)
// We set it later after fetch loads.
window.GG_MARKER_DATA = [];

// A function we will define later (inside module script) to add markers on click.
window.GG_ADD_MARKER_AT = null;
window.GG_PENDING_ADD_LATLNGS = [];

// Show export button in edit mode and wire export
(function initEditorUI() {
  const btn = document.getElementById("exportMarkers");
  if (!btn) return;

  if (window.GG_EDIT_MODE) {
    btn.style.display = "block";
    btn.addEventListener("click", async () => {
      // Sort a COPY for export (doesn't affect your live array order)
      const sorted = [...window.GG_MARKER_DATA].sort((a, b) => {
        // Sort by full id (layer:id) so it‚Äôs deterministic across layers
        const ak = `${a.layer ?? ""}:${String(a.id ?? "")}`;
        const bk = `${b.layer ?? ""}:${String(b.id ?? "")}`;

        // numeric:true makes "c2" come before "c10"
        return ak.localeCompare(bk, undefined, { numeric: true, sensitivity: "base" });
      });

      const json = JSON.stringify(sorted, null, 2);

      try {
        await navigator.clipboard.writeText(json);
        alert("Marker JSON (sorted) copied to clipboard!");
      } catch (err) {
        console.log(json);
        alert("Clipboard blocked ‚Äî sorted JSON printed to console.");
      }

      console.log(json);
    });
  }
})();


const SVG_ICONS = {
  crystals: `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
      <defs>
        <!-- Glow gradient -->
        <radialGradient id="coreGlow" cx="50%" cy="35%" r="60%">
          <stop offset="0%" stop-color="#b6ffb6"/>
          <stop offset="50%" stop-color="#32ff6a"/>
          <stop offset="100%" stop-color="#0b5f2a"/>
        </radialGradient>

        <!-- Outer crystal gradient -->
        <linearGradient id="crystalBody" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" stop-color="#7dffb0"/>
          <stop offset="100%" stop-color="#1a7f46"/>
        </linearGradient>

        <!-- Soft glow -->
        <filter id="glow">
          <feGaussianBlur stdDeviation="2" result="blur"/>
          <feMerge>
            <feMergeNode in="blur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- Glow aura -->
      <polygon
        points="32,4 52,22 40,58 24,58 12,22"
        fill="url(#coreGlow)"
        opacity="0.6"
        filter="url(#glow)"
      />

      <!-- Crystal body -->
      <polygon
        points="32,6 50,22 38,56 26,56 14,22"
        fill="url(#crystalBody)"
        stroke="#b6ffd1"
        stroke-width="1.5"
      />

      <!-- Facet highlights -->
      <polygon points="32,6 40,24 32,56" fill="#aaffcc" opacity="0.35"/>
      <polygon points="32,6 24,24 32,56" fill="#4fdc8c" opacity="0.35"/>

    </svg>

  `,
  gberry: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="24"
      height="24"
      fill="none"
      stroke="#000"
      stroke-width="3"
      stroke-linecap="round"
      stroke-linejoin="round"
      aria-label="Strawberry icon"
    >
      <!-- Leaves -->
      <path d="M16 16
              C20 10 26 12 28 16
              C30 10 34 10 36 16
              C38 12 44 10 48 16" />

      <!-- Stem -->
      <line x1="32" y1="10" x2="32" y2="18" />

      <!-- Strawberry body -->
      <path
        d="M16 24
          C16 38 24 54 32 56
          C40 54 48 38 48 24
          C48 18 42 14 32 14
          C22 14 16 18 16 24Z"
        fill="#FFD700"
      />

      <!-- Seeds -->
      <g stroke-width="2">
        <!-- Upper -->
        <circle cx="26" cy="30" r="1"/>
        <circle cx="32" cy="28" r="1"/>
        <circle cx="38" cy="30" r="1"/>

        <!-- Middle -->
        <circle cx="24" cy="36" r="1"/>
        <circle cx="32" cy="36" r="1"/>
        <circle cx="40" cy="36" r="1"/>

        <!-- Lower -->
        <circle cx="28" cy="42" r="1"/>
        <circle cx="36" cy="42" r="1"/>

        <circle cx="32" cy="48" r="1"/>
      </g>
    </svg>
  `,
  mberry: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="24"
      height="24"
      fill="none"
      stroke="#000"
      stroke-width="3"
      stroke-linecap="round"
      stroke-linejoin="round"
      aria-label="Strawberry icon"
    >
      <!-- Leaves -->
      <path d="M16 16
              C20 10 26 12 28 16
              C30 10 34 10 36 16
              C38 12 44 10 48 16" />

      <!-- Stem -->
      <line x1="32" y1="10" x2="32" y2="18" />

      <!-- Strawberry body -->
      <path
        d="M16 24
          C16 38 24 54 32 56
          C40 54 48 38 48 24
          C48 18 42 14 32 14
          C22 14 16 18 16 24Z"
        fill="#8bfbdb"
      />

      <!-- Seeds -->
      <g stroke-width="2">
        <!-- Upper -->
        <circle cx="26" cy="30" r="1"/>
        <circle cx="32" cy="28" r="1"/>
        <circle cx="38" cy="30" r="1"/>

        <!-- Middle -->
        <circle cx="24" cy="36" r="1"/>
        <circle cx="32" cy="36" r="1"/>
        <circle cx="40" cy="36" r="1"/>

        <!-- Lower -->
        <circle cx="28" cy="42" r="1"/>
        <circle cx="36" cy="42" r="1"/>

        <circle cx="32" cy="48" r="1"/>
      </g>
    </svg>
  `,
  seed: `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="14" height="14" aria-label="Strawberry seed">
      <path
        d="M12 3
          C16 6, 18 10, 12 21
          C6 10, 8 6, 12 3Z"
        fill="#2e7d32"
        stroke="#0b2a12"
        stroke-width="1.5"
        stroke-linejoin="round"
      />
      <path
        d="M10 7
          C9 9, 9.5 10.5, 11 11.5"
        fill="none"
        stroke="#a5d6a7"
        stroke-width="1.5"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  keys: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Golden key"
    >
      <!-- Key head -->
      <circle
        cx="20"
        cy="32"
        r="12"
        fill="#FFD700"
        stroke="#B8860B"
        stroke-width="3"
      />

      <!-- Head hole -->
      <circle
        cx="20"
        cy="32"
        r="4"
        fill="none"
        stroke="#8a6f00"
        stroke-width="2"
      />

      <!-- Shaft -->
      <rect
        x="32"
        y="28"
        width="22"
        height="8"
        rx="2"
        fill="#FFD700"
        stroke="#B8860B"
        stroke-width="2"
      />

      <!-- Teeth -->
      <rect
        x="46"
        y="36"
        width="6"
        height="8"
        fill="#FFD700"
        stroke="#8a6f00"
        stroke-width="2"
      />
      <rect
        x="38"
        y="36"
        width="6"
        height="5"
        fill="#FFD700"
        stroke="#8a6f00"
        stroke-width="2"
      />

      <!-- Highlight -->
      <path
        d="M14 24
          C12 28 12 36 14 40"
        fill="none"
        stroke="#FFF2A8"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  locks: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Lock"
    >
      <!-- Shackle -->
      <path
        d="M20 28
          V18
          C20 10 26 6 32 6
          C38 6 44 10 44 18
          V28"
        fill="none"
        stroke="#555555"
        stroke-width="4"
        stroke-linecap="round"
      />

      <!-- Lock body -->
      <rect
        x="14"
        y="28"
        width="36"
        height="30"
        rx="6"
        fill="#FFD700"
        stroke="#B8860B"
        stroke-width="3"
      />

      <!-- Keyhole -->
      <circle
        cx="32"
        cy="42"
        r="4"
        fill="#8a6f00"
      />
      <rect
        x="30.5"
        y="42"
        width="3"
        height="8"
        fill="#8a6f00"
      />

      <!-- Highlight -->
      <path
        d="M20 32
          C18 36 18 46 20 50"
        fill="none"
        stroke="#FFF2A8"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  blueHeart: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="24"
      height="24"
      aria-label="Blue Crystal Heart"
      <g transform="translate(0 3)">
    >
      <!-- Outer heart -->
      <path
        d="M32 56
          C32 56 8 36 8 22
          C8 14 14 8 22 8
          C27 8 32 12 32 12
          C32 12 37 8 42 8
          C50 8 56 14 56 22
          C56 36 32 56 32 56Z"
        fill="#2196f3"
        stroke="#000"
        stroke-width="3"
        stroke-linejoin="round"
      />

      <!-- Facet lines -->
      <path d="M32 12 V56" stroke="#0d47a1" stroke-width="2"/>
      <path d="M22 18 L32 30 L42 18" stroke="#0d47a1" stroke-width="2" fill="none"/>
      <path d="M16 26 L32 44 L48 26" stroke="#0d47a1" stroke-width="2" fill="none"/>

      <!-- Highlight -->
      <path
        d="M24 16
          C18 20 16 26 18 30"
        stroke="#bbdefb"
        stroke-width="2"
        fill="none"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  redHeart: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="24"
      height="24"
      aria-label="Red Crystal Heart"
    >
      <!-- Shift entire heart DOWN by 4 units -->
      <g transform="translate(0 4)">
        <!-- Outer heart -->
        <path
          d="M32 56
            C32 56 8 36 8 22
            C8 14 14 8 22 8
            C27 8 32 12 32 12
            C32 12 37 8 42 8
            C50 8 56 14 56 22
            C56 36 32 56 32 56Z"
          fill="#e53935"
          stroke="#000"
          stroke-width="3"
          stroke-linejoin="round"
        />

        <!-- Facet lines -->
        <path d="M32 12 V56" stroke="#8e0000" stroke-width="2"/>
        <path d="M22 18 L32 30 L42 18" stroke="#8e0000" stroke-width="2" fill="none"/>
        <path d="M16 26 L32 44 L48 26" stroke="#8e0000" stroke-width="2" fill="none"/>

        <!-- Highlight -->
        <path
          d="M24 16
            C18 20 16 26 18 30"
          stroke="#ffcdd2"
          stroke-width="2"
          fill="none"
          stroke-linecap="round"
          opacity="0.9"
        />
      </g>
    </svg>
  `,
  goldHeart: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="24"
      height="24"
      aria-label="Gold Crystal Heart"
    >
      <!-- Shift entire heart DOWN by 4 units -->
      <g transform="translate(0 4)">
        <!-- Outer heart -->
        <path
          d="M32 56
            C32 56 8 36 8 22
            C8 14 14 8 22 8
            C27 8 32 12 32 12
            C32 12 37 8 42 8
            C50 8 56 14 56 22
            C56 36 32 56 32 56Z"
          fill="#FFD700"
          stroke="#000"
          stroke-width="3"
          stroke-linejoin="round"
        />

        <!-- Facet lines -->
        <path d="M32 12 V56" stroke="#B8860B" stroke-width="2"/>
        <path d="M22 18 L32 30 L42 18" stroke="#B8860B" stroke-width="2" fill="none"/>
        <path d="M16 26 L32 44 L48 26" stroke="#B8860B" stroke-width="2" fill="none"/>

        <!-- Highlight -->
        <path
          d="M24 16
            C18 20 16 26 18 30"
          stroke="#FFF2A8"
          stroke-width="2"
          fill="none"
          stroke-linecap="round"
          opacity="0.95"
        />
      </g>
    </svg>
  `,
  grayHeart: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="24"
      height="24"
      aria-label="Gray Crystal Heart"
    >
      <!-- Shift entire heart DOWN by 4 units -->
      <g transform="translate(0 4)">
        <!-- Outer heart -->
        <path
          d="M32 56
            C32 56 8 36 8 22
            C8 14 14 8 22 8
            C27 8 32 12 32 12
            C32 12 37 8 42 8
            C50 8 56 14 56 22
            C56 36 32 56 32 56Z"
          fill="#d5ede0"
          stroke="#000"
          stroke-width="3"
          stroke-linejoin="round"
        />

        <!-- Facet lines -->
        <path d="M32 12 V56" stroke="#B8860B" stroke-width="2"/>
        <path d="M22 18 L32 30 L42 18" stroke="#B8860B" stroke-width="2" fill="none"/>
        <path d="M16 26 L32 44 L48 26" stroke="#B8860B" stroke-width="2" fill="none"/>

        <!-- Highlight -->
        <path
          d="M24 16
            C18 20 16 26 18 30"
          stroke="#FFF2A8"
          stroke-width="2"
          fill="none"
          stroke-linecap="round"
          opacity="0.95"
        />
      </g>
    </svg>
  `,
  tapes: `
    <svg class="filter-icon" viewBox="0 0 24 24" aria-label="Cassette tape">
      <!-- Outer cassette body -->
      <rect
        x="3"
        y="5"
        width="18"
        height="14"
        rx="2"
        fill="none"
        stroke="white"
        stroke-width="2"
      />

      <!-- Top label window -->
      <rect
        x="6"
        y="7"
        width="12"
        height="4"
        rx="1"
        fill="none"
        stroke="white"
        stroke-width="1.5"
      />

      <!-- Left reel -->
      <circle
        cx="8.5"
        cy="14"
        r="2"
        fill="none"
        stroke="white"
        stroke-width="1.5"
      />

      <!-- Right reel -->
      <circle
        cx="15.5"
        cy="14"
        r="2"
        fill="none"
        stroke="white"
        stroke-width="1.5"
      />

      <!-- Tape window -->
      <line
        x1="10.5"
        y1="14"
        x2="13.5"
        y2="14"
        stroke="white"
        stroke-width="1.5"
        stroke-linecap="round"
      />
    </svg>
  `,
  walls: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="24"
      height="24"
      fill="none"
      stroke="currentColor"
      stroke-width="3"
      stroke-linecap="round"
      stroke-linejoin="round"
      aria-label="Smashable wall icon"
    >
      <!-- Outer wall -->
      <rect x="10" y="12" width="44" height="40" rx="4"/>

      <!-- Brick lines -->
      <path d="M12 24H52"/>
      <path d="M12 36H52"/>
      <path d="M12 48H52"/>

      <!-- Vertical mortar (staggered bricks) -->
      <path d="M22 12V24"/>
      <path d="M42 12V24"/>
      <path d="M16 24V36"/>
      <path d="M32 24V36"/>
      <path d="M48 24V36"/>
      <path d="M22 36V48"/>
      <path d="M42 36V48"/>
      <path d="M16 48V52"/>
      <path d="M32 48V52"/>
      <path d="M48 48V52"/>

      <!-- Crack -->
      <path d="M34 16
              L30 22
              L36 28
              L28 34
              L34 40
              L26 48" />

      <!-- Small chips -->
      <path d="M46 30 L50 28"/>
      <path d="M44 44 L48 46"/>
    </svg>
  `,
  topaz: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Topaz jewel"
    >
      <!-- Outer gem -->
      <path
        d="M32 4
          L54 18
          L46 56
          H18
          L10 18
          Z"
        fill="#fbc02d"
        stroke="#f57f17"
        stroke-width="3"
        stroke-linejoin="round"
      />

      <!-- Facet lines -->
      <path d="M32 4 V56" stroke="#f57f17" stroke-width="2"/>
      <path d="M10 18 L32 32 L54 18" stroke="#f57f17" stroke-width="2" fill="none"/>
      <path d="M18 56 L32 32 L46 56" stroke="#f57f17" stroke-width="2" fill="none"/>

      <!-- Inner facet -->
      <polygon
        points="32,14 44,24 32,46 20,24"
        fill="#ffe082"
        opacity="0.9"
      />

      <!-- Highlight -->
      <path
        d="M22 18
          C20 22 20 28 22 32"
        fill="none"
        stroke="#fff8e1"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  diamond: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Pink diamond jewel"
    >
      <!-- Outer diamond -->
      <path
        d="M32 4
          L56 20
          L44 56
          H20
          L8 20
          Z"
        fill="#ec407a"
        stroke="#ad1457"
        stroke-width="3"
        stroke-linejoin="round"
      />

      <!-- Facet lines -->
      <path d="M32 4 V56" stroke="#ad1457" stroke-width="2"/>
      <path d="M8 20 L32 32 L56 20" stroke="#ad1457" stroke-width="2" fill="none"/>
      <path d="M20 56 L32 32 L44 56" stroke="#ad1457" stroke-width="2" fill="none"/>

      <!-- Inner facet -->
      <polygon
        points="32,14 44,24 32,46 20,24"
        fill="#f48fb1"
        opacity="0.9"
      />

      <!-- Highlight -->
      <path
        d="M22 18
          C20 22 20 28 22 32"
        fill="none"
        stroke="#fce4ec"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  pearl: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Pearl"
    >
      <!-- Pearl body -->
      <circle
        cx="32"
        cy="32"
        r="22"
        fill="#f5f5f5"
        stroke="#bdbdbd"
        stroke-width="3"
      />

      <!-- Soft inner shading -->
      <circle
        cx="36"
        cy="36"
        r="16"
        fill="#eeeeee"
        opacity="0.9"
      />

      <!-- Highlight -->
      <path
        d="M22 22
          C18 24 18 30 22 34"
        fill="none"
        stroke="#ffffff"
        stroke-width="3"
        stroke-linecap="round"
        opacity="0.9"
      />

      <!-- Subtle shadow edge -->
      <path
        d="M42 42
          C44 40 46 36 46 32"
        fill="none"
        stroke="#cfcfcf"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.6"
      />
    </svg>
  `,
  NPC: `
    <svg class="filter-icon" viewBox="0 0 24 24"><path d="M12 2a5 5 0 1 1 0 10 5 5 0 0 1 0-10zm0 12c-4 0-8 2-8 6v2h16v-2c0-4-4-6-8-6z"/></svg>
  `,
  emerald: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Emerald jewel"
    >
      <!-- Outer gem (emerald cut) -->
      <path
        d="M18 6
          H46
          L58 18
          V46
          L46 58
          H18
          L6 46
          V18
          Z"
        fill="#2e7d32"
        stroke="#1b5e20"
        stroke-width="3"
        stroke-linejoin="round"
      />

      <!-- Facet lines -->
      <path d="M32 6 V58" stroke="#1b5e20" stroke-width="2"/>
      <path d="M6 18 L32 32 L58 18" stroke="#1b5e20" stroke-width="2" fill="none"/>
      <path d="M18 58 L32 32 L46 58" stroke="#1b5e20" stroke-width="2" fill="none"/>

      <!-- Inner facet -->
      <rect
        x="22"
        y="22"
        width="20"
        height="20"
        fill="#66bb6a"
        opacity="0.9"
      />

      <!-- Highlight -->
      <path
        d="M22 16
          C20 20 20 26 22 30"
        fill="none"
        stroke="#c8e6c9"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  sapphire: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Sapphire jewel"
    >
      <!-- Outer gem -->
      <path
        d="M32 4
          L52 20
          L44 56
          H20
          L12 20
          Z"
        fill="#1e88e5"
        stroke="#0d47a1"
        stroke-width="3"
        stroke-linejoin="round"
      />

      <!-- Facet lines -->
      <path d="M32 4 V56" stroke="#0d47a1" stroke-width="2"/>
      <path d="M12 20 L32 32 L52 20" stroke="#0d47a1" stroke-width="2" fill="none"/>
      <path d="M20 56 L32 32 L44 56" stroke="#0d47a1" stroke-width="2" fill="none"/>

      <!-- Inner facet -->
      <polygon
        points="32,14 42,24 32,44 22,24"
        fill="#42a5f5"
        opacity="0.9"
      />

      <!-- Highlight -->
      <path
        d="M22 18
          C20 22 20 28 22 32"
        fill="none"
        stroke="#bbdefb"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  star: `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      width="22"
      height="22"
      aria-label="Star jewel"
    >
      <!-- Outer star -->
      <path
        d="M32 4
          L39.5 22.5
          L60 24
          L44.5 38
          L49 58
          L32 47
          L15 58
          L19.5 38
          L4 24
          L24.5 22.5
          Z"
        fill="#FFD700"
        stroke="#B8860B"
        stroke-width="3"
        stroke-linejoin="round"
      />

      <!-- Facet lines -->
      <path d="M32 4 L32 47" stroke="#B8860B" stroke-width="2"/>
      <path d="M24.5 22.5 L32 32 L39.5 22.5" stroke="#B8860B" stroke-width="2" fill="none"/>
      <path d="M19.5 38 L32 32 L44.5 38" stroke="#B8860B" stroke-width="2" fill="none"/>

      <!-- Highlight -->
      <path
        d="M22 20
          C20 24 20 30 22 34"
        fill="none"
        stroke="#FFF2A8"
        stroke-width="2"
        stroke-linecap="round"
        opacity="0.9"
      />
    </svg>
  `,
  secrets: `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <!-- Question mark curve -->
      <path d="
        M12 2
        C8.7 2, 6.2 4.1, 6.2 7
        H8.6
        C8.6 5.4, 9.9 4.4, 12 4.4
        C14 4.4, 15.4 5.5, 15.4 7.2
        C15.4 8.7, 14.4 9.5, 12.9 10.4
        C11.2 11.4, 10.6 12.3, 10.6 14
        V15.2
        H13
        V14.4
        C13 13.2, 13.6 12.7, 15.2 11.7
        C17 10.6, 18 9.3, 18 7.1
        C18 4.2, 15.3 2, 12 2
        Z
      "/>

      <!-- Dot -->
      <circle cx="12" cy="18.5" r="1.6"/>
    </svg>
  `
};

const SVG_SIZES = {
  crystals: 36,
  hearts: 35,
  tapes: 25,
  walls: 30,
  NPC: 25,
  secrets: 30,
  keys: 35,
};

function createSvgMarker(category, isFound = false, iconKey = null, isLocked = false) {
  const size = SVG_SIZES[category] ?? 18;
  const catClass = String(category).trim().toLowerCase();
  const svg = SVG_ICONS[iconKey] || SVG_ICONS[category];

  // ‚úÖ only show red outline in edit mode
  const lockClass = (window.GG_EDIT_MODE && isLocked) ? "marker-locked" : "";

  return L.divIcon({
    className: '',
    iconSize: [34, 44],
    iconAnchor: [19, 44],
    popupAnchor: [1, -41],
    html: `
      <div class="marker marker-${catClass} ${isFound ? 'marker-found' : ''} ${lockClass}">
        <div style="
          width:${size}px;
          height:${size}px;
          display:flex;
          align-items:center;
          justify-content:center;
          transform: rotate(45deg);
        ">
          ${svg}
        </div>
      </div>
    `
  });
}

/* ---------- MAP ---------- */
var map = L.map('map', { 
  zoomControl: false,
  attributionControl: false
});

const tileLayers = {
  viewros: {
    layer: L.tileLayer('tiles/viewros/{z}/{x}/{y}.png', {
      maxZoom: 5,
      minZoom: 2,
      noWrap: true,
      bounds: [[-76,-180],[85.05,110.8]]
    }),
    defaultZoom: 2,
    defaultCenter: [60, -30]
  },

  fury: {
    layer: L.tileLayer('tiles/fury/{z}/{x}/{y}.png', {
      maxZoom: 7,
      maxNativeZoom: 6,  
      minZoom: 3,
      noWrap: true,
      bounds: [[-69.78,-180],[85,110.4]]
    }),
    defaultZoom: 3,
    defaultCenter: [77.39, -83.7]
  }
};

let currentLayer = "viewros";
tileLayers[currentLayer].layer.addTo(map);
map.setView(
  tileLayers[currentLayer].defaultCenter,
  tileLayers[currentLayer].defaultZoom
);

const markers = {};
const foundMarkers = {};
let hideFound = false;

let totalCount = 0;

/* ---------- PROGRESS COUNTER UPDATER ---------- */
function updateProgressDisplay() {
  const foundCount = Object.keys(foundMarkers).length;
  const percent = totalCount > 0 ? Math.round((foundCount / totalCount) * 100) : 0;

  document.getElementById("progressDetails").innerText =
    `${foundCount} / ${totalCount} (${percent}%)`;

  // Update progress bar width
  document.getElementById("progressBarInner").style.width = percent + "%";

  // Handle 100% star
  const star = document.getElementById("progressStar");

  if (percent === 100) {
    star.style.display = "inline-block"; // show star
    star.style.opacity = "1";
    star.style.transform = "scale(1)";
  } else {
    star.style.display = "none"; // remove star from layout
  }
}

/* ---------- HELPER FUNCTIONS ---------- */

function stopAllPopupVideos() {
  document.querySelectorAll(".leaflet-popup video").forEach(video => {
    video.pause();
    video.removeAttribute("src"); // optional: frees memory
    video.load();
  });
}

function jumpToMarker(targetId, zoomOverride = null) {
  const allMarkers = { ...markers, ...foundMarkers };
  const target = allMarkers[targetId];
  if (!target) return;

  forcedVisibleMarkers.add(targetId);

  const targetZoom = zoomOverride ?? map.getZoom();

  const showTarget = () => {
    target.addTo(map); // üîë MUST be on map
    map.setView(target.getLatLng(), targetZoom, { animate: true });
    target.openPopup();

    target.once("popupclose", () => {
      forcedVisibleMarkers.delete(targetId);
      updateMarkersByCategory();
    });
  };

  // Switch layer if needed
  if (target.mapLayer !== currentLayer) {
    const newLayer = tileLayers[target.mapLayer].layer;

    document.getElementById("layerSelect").value = target.mapLayer;
    document.getElementById("layerSelect").dispatchEvent(new Event("change"));

    // Wait for tiles to load before opening popup
    newLayer.once("load", () => {
      requestAnimationFrame(showTarget);
    });
  } else {
    requestAnimationFrame(showTarget);
  }

  map.panTo(target.getLatLng());
}


document.getElementById("layerSelect").addEventListener("change", e => {
  stopAllPopupVideos();

  const newLayerKey = e.target.value;
  if (newLayerKey === currentLayer) return;

  const oldLayer = tileLayers[currentLayer].layer;
  const newLayer = tileLayers[newLayerKey].layer;
  const { defaultCenter, defaultZoom } = tileLayers[newLayerKey];

  // Add new layer FIRST (keeps old tiles visible)
  newLayer.addTo(map);

  // Lock view instantly (no animation = no stutter)
  map.setView(defaultCenter, defaultZoom, {
    animate: false,
    reset: true
  });

  // Wait until new tiles are ready
  newLayer.once("load", () => {
    map.removeLayer(oldLayer);
  });

  currentLayer = newLayerKey;

  updateMarkersByCategory();
});

// Make sidebar subcategories collapsible
document.querySelectorAll('.subcategory').forEach(section => {
  const header = section.querySelector('h3');
  const content = section.querySelector('.subcategory-content');

  // Start expanded
  section.classList.remove("collapsed");

  header.addEventListener('click', () => {
    section.classList.toggle("collapsed");
  });
});

const searchInput = document.getElementById('markerSearch');

/* ---------- HIDE/SHOW FOUND ---------- */
document.getElementById("foundToggle").onclick = () => {
  hideFound = !hideFound;

  if (hideFound) {
    Object.values(foundMarkers).forEach(m => map.removeLayer(m));
    document.getElementById("foundToggle").innerText = "Show Found Items";
  } else {
    Object.values(foundMarkers).forEach(m => m.addTo(map));
    document.getElementById("foundToggle").innerText = "Hide Found Items";
  }
};

/* ---------- SHOW ALL / HIDE ALL CATEGORY TOGGLES ---------- */
document.getElementById("showAllBtn").onclick = () => {
  document.querySelectorAll('.category').forEach(box => box.checked = true);
  updateMarkersByCategory();
};

document.getElementById("hideAllBtn").onclick = () => {
  document.querySelectorAll('.category').forEach(box => box.checked = false);
  updateMarkersByCategory();
};

/* ---------- CATEGORY FILTERING ---------- */
function updateMarkersByCategory() {
  const active = [...document.querySelectorAll('.category:checked')].map(x => x.value);

  [...Object.values(markers), ...Object.values(foundMarkers)].forEach(m => {
    if ((active.includes(m.category) || forcedVisibleMarkers.has(m.__id)) && m.mapLayer === currentLayer && !(hideFound && Object.values(foundMarkers).includes(m))) {
      m.addTo(map);
    } else {
      map.removeLayer(m);
    }
  });
}

document.querySelectorAll('.category').forEach(b => {
  b.addEventListener('change', updateMarkersByCategory);
});

function updateMarkersBySearch() {
  const query = searchInput.value.toLowerCase();
  const activeCategories = [...document.querySelectorAll('.category:checked')].map(x => x.value);

  if (!query) {
    updateMarkersByCategory();
    return;
  }

  [...Object.values(markers), ...Object.values(foundMarkers)].forEach(marker => {
    const matchesCategory = activeCategories.includes(marker.category) || forcedVisibleMarkers.has(marker.__id);
    
    // Check if query is in title or description
    const titleMatch = marker.options.title.toLowerCase().includes(query);
    const descMatch = marker.description && marker.description.toLowerCase().includes(query);
    const matchesSearch = titleMatch || descMatch;

    if (matchesCategory && matchesSearch && marker.mapLayer === currentLayer && !(hideFound && Object.values(foundMarkers).includes(marker))) {
      marker.addTo(map);
    } else {
      map.removeLayer(marker);
    }
  });
}

// Run live search whenever input changes
searchInput.addEventListener('input', updateMarkersBySearch);

// Make category filtering also respect search
function updateMarkersByCategoryAndSearch() {
  updateMarkersBySearch();
}

// Update category event listener
document.querySelectorAll('.category').forEach(b => {
  b.addEventListener('change', updateMarkersByCategoryAndSearch);
});

map.on("click", (e) => {
  if (window.GG_EDIT_MODE) {
    if (window.GG_COPIED_MARKER) {
      window.pasteCopiedMarkerAt(e.latlng);
    } else if (typeof window.GG_ADD_MARKER_AT === "function") {
      window.GG_ADD_MARKER_AT(e.latlng);
    } else {
      // Queue the click so it works once markers/module are ready
      window.GG_PENDING_ADD_LATLNGS.push(e.latlng);
      console.warn("Edit mode active, marker tools not ready yet ‚Äî queued click.");
    }
    return;
  }
});

</script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
  import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";

  // Firebase config
  const firebaseConfig = {
      apiKey: "AIzaSyBGI-tSZjsy7wvNSu3D_lFZR96TQND-uJU",
      authDomain: "gamegazetteer-bfed2.firebaseapp.com",
      projectId: "gamegazetteer-bfed2",
      storageBucket: "gamegazetteer-bfed2.appspot.com",
      messagingSenderId: "659845857638",
      appId: "1:659845857638:web:7ad66baffa924961a948a7",
      measurementId: "G-Q8QP2RD1BL"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  // const analytics = getAnalytics(app);
  const auth = getAuth();
  const db = getFirestore();

  let isLoggedIn = false;

  let didLoadMarkers = false;

  function applyLockState(marker, locked) {
    marker.isLocked = !!locked;

    // IMPORTANT: options.draggable must reflect lock state
    marker.options.draggable = window.GG_EDIT_MODE && !marker.isLocked;

    const drag = ensureDragging(marker);
    if (drag) {
      if (marker.options.draggable) drag.enable();
      else drag.disable();
    }
  }

  function ensureDragging(marker) {
    // If Leaflet already attached dragging, great
    if (marker.dragging) return marker.dragging;

    // Force-create the drag handler if Leaflet didn't
    if (window.L?.Handler?.MarkerDrag) {
      marker.dragging = new L.Handler.MarkerDrag(marker);
      return marker.dragging;
    }

    return null;
  }

  function attachRightClick(marker) {
    // Remove any old handler if this gets called twice
    marker.off("contextmenu");

    marker.on("contextmenu", (e) => {
      // Stop the browser context menu + stop Leaflet propagation
      if (e?.originalEvent) {
        e.originalEvent.preventDefault();
        e.originalEvent.stopPropagation();
      }
      if (window.L?.DomEvent) L.DomEvent.stop(e);

      // EDIT MODE: toggle locked
      if (window.GG_EDIT_MODE) {
        const nowLocked = !marker.isLocked;

        // keep JSON clean
        if (marker.__dataRef) {
          if (nowLocked) marker.__dataRef.locked = true;
          else delete marker.__dataRef.locked;
        }

        applyLockState(marker, nowLocked);

        // refresh icon (red outline only in edit mode)
        marker.setIcon(
          createSvgMarker(marker.category, marker.isFound, marker.iconKey, nowLocked)
        );

        // rebuild popup so the lock checkbox reflects the new state
        createMarkerPopup(marker, marker.__id);

        return;
      }

      // NORMAL MODE: toggle found
      toggleFound(marker.__id, { checked: !marker.isFound });
    });
  }

  async function loadMarkers(foundIds) {
    if (didLoadMarkers) return;
    didLoadMarkers = true;

    fetch('metroid-prime-4-markers.json')
      .then(res => res.json())
      .then(data => {
        window.GG_MARKER_DATA = data;
        totalCount = data.length;

        data.forEach(point => {
          const id = `${point.layer}:${point.id}`;
          const isFound = foundIds.includes(id);

          const marker = L.marker(point.coords, {
            icon: createSvgMarker(point.category, isFound, point.icon, !!point.locked),
            title: point.name,
            draggable: window.GG_EDIT_MODE && !point.locked
          });

          marker.__dataRef = point;
          applyLockState(marker, !!point.locked);

          if (window.GG_EDIT_MODE) {
            // Ensure dragging exists even if Leaflet didn't attach it for some reason

            const drag = ensureDragging(marker);
            if (drag) {
              if (marker.isLocked) drag.disable();
              else drag.enable();
            }

            marker.on("dragend", () => {
              const pos = marker.getLatLng();
              point.coords = [pos.lat, pos.lng];
            });
          }

          marker.category = point.category;
          marker.description = point.description;
          marker.links = point.links || [];
          marker.isFound = isFound;
          marker.mapLayer = point.layer || currentLayer;
          marker.__id = id;
          marker.iconKey = point.icon;
          marker.mp4 = point.mp4;
          marker.image = point.image;

          if (isFound) foundMarkers[id] = marker;
          else markers[id] = marker;

          if (marker.mapLayer === currentLayer) marker.addTo(map);

          createMarkerPopup(marker, id);
          attachRightClick(marker);

        });

        updateProgressDisplay();
        updateMarkersByCategory();
        // Flush any queued map clicks from edit mode
        if (window.GG_PENDING_ADD_LATLNGS?.length && typeof window.GG_ADD_MARKER_AT === "function") {
          const queued = [...window.GG_PENDING_ADD_LATLNGS];
          window.GG_PENDING_ADD_LATLNGS.length = 0;
          queued.forEach(ll => window.GG_ADD_MARKER_AT(ll));
        }
      })
      .catch(err => {
        console.error("Marker JSON load failed:", err);
      });
  }

  // Check Logged in
  onAuthStateChanged(auth, async user => {
    let foundIds = [];

    try {
      if (user) {
        isLoggedIn = true;
        foundIds = await loadFoundMarkersFromFirebase(user);
      } else {
        isLoggedIn = false;
        foundIds = Object.keys(localStorage)
          .filter(k => k.startsWith("found_") && localStorage.getItem(k) === "true")
          .map(k => k.replace("found_", ""));
      }
    } catch (e) {
      console.error("Auth/progress load failed, falling back:", e);
      isLoggedIn = false;
      foundIds = Object.keys(localStorage)
        .filter(k => k.startsWith("found_") && localStorage.getItem(k) === "true")
        .map(k => k.replace("found_", ""));
    }

    await loadMarkers(foundIds);
  });

  // LOAD found markers from Firebase
  async function loadFoundMarkersFromFirebase(user) {
    try {
        const ref = doc(db, "users", user.uid, "progress", "foundMarkers");
        const snap = await getDoc(ref);

        if (!snap.exists()) return [];

        const found = snap.data().found;

        return Array.isArray(found) ? found : [];
    } 
    catch (err) {
        console.error("FIREBASE READ ERROR:", err);
        return [];
    }
  }


  // SAVE found markers TO Firebase
  async function saveFoundMarkersToFirebase(user, foundIdsArray) {
      const ref = doc(db, "users", user.uid, "progress", "foundMarkers");
      await setDoc(ref, { found: foundIdsArray });
  }

  /* ---------- SIDEBAR TOGGLE ---------- */
  document.getElementById("toggleSidebar").onclick = () => {
    const side = document.getElementById("controls");
    side.style.display = side.style.display === "none" ? "block" : "none";
  };

  async function toggleFound(id, checkbox) {
    const marker = markers[id] || foundMarkers[id];
    if (!marker) return;

    const isNowFound = checkbox.checked;
    marker.isFound = isNowFound;

    if (isNowFound) {
      marker.setIcon(createSvgMarker(marker.category, marker.isFound, marker.iconKey, !!marker.isLocked));
      delete markers[id];
      foundMarkers[id] = marker;
    } else {
      marker.setIcon(createSvgMarker(marker.category, marker.isFound, marker.iconKey, !!marker.isLocked));
      delete foundMarkers[id];
      markers[id] = marker;
    }

    if (isLoggedIn && auth.currentUser) {
      // update foundIds array
      let foundIds = Object.keys(foundMarkers);
      if (isNowFound && !foundIds.includes(String(id))) foundIds.push(String(id));
      if (!isNowFound) foundIds = foundIds.filter(x => x !== String(id));

      await saveFoundMarkersToFirebase(auth.currentUser, foundIds);
    } else {
      // fallback to localStorage
      if (isNowFound) localStorage.setItem(`found_${id}`, "true");
      else localStorage.removeItem(`found_${id}`);
    }

    updateMarkersByCategory();
    updateProgressDisplay();

    createMarkerPopup(marker, id);
    marker.openPopup();
  }

  // ============================
  // EDIT MODE: Copy/Paste Marker
  // ============================
  window.GG_COPIED_MARKER = null;        // holds a JSON-ish point template
  window.GG_SELECTED_MARKER = null;      // last popup-opened marker

  function makeUniqueId(baseId, layer) {
    const base = String(baseId ?? "").trim();
    if (!base) return null;

    const exists = (fullId) => (markers[fullId] || foundMarkers[fullId]);
    const full = (id) => `${layer}:${id}`;

    // If base doesn't exist yet, use it
    if (!exists(full(base))) return base;

    // Otherwise try base2, base3, ...
    let n = 2;
    while (n < 10000) {
      const candidate = `${base}${n}`;
      if (!exists(full(candidate))) return candidate;
      n++;
    }
    return null;
  }

  function removePointFromMarkerData(fullId) {
    // fullId looks like "layer:id"
    const [layer, id] = String(fullId).split(":");
    const idx = window.GG_MARKER_DATA.findIndex(p => String(p.layer) === String(layer) && String(p.id) === String(id));
    if (idx >= 0) window.GG_MARKER_DATA.splice(idx, 1);
    totalCount = window.GG_MARKER_DATA.length;
  }

  function deleteMarkerEverywhere(fullId) {
    const m = markers[fullId] || foundMarkers[fullId];
    if (!m) return;

    // Remove from map
    try { map.removeLayer(m); } catch {}

    // Remove from buckets
    delete markers[fullId];
    delete foundMarkers[fullId];

    // Remove from raw JSON
    removePointFromMarkerData(fullId);

    // Remove found-state persistence for this id (best-effort)
    try {
      localStorage.removeItem(`found_${fullId}`);
    } catch {}

    // Update UI
    updateMarkersByCategory();
    updateProgressDisplay();
  }

  function clonePointTemplateFromMarker(marker) {
    const p = marker?.__dataRef;
    if (!p) return null;

    // Clone only the marker JSON fields you care about
    return {
      id: p.id,
      layer: p.layer ?? marker.mapLayer ?? currentLayer,
      coords: Array.isArray(p.coords) ? [...p.coords] : [marker.getLatLng().lat, marker.getLatLng().lng],
      category: p.category ?? marker.category ?? "crystals",
      icon: p.icon ?? marker.iconKey ?? "crystals",
      name: p.name ?? marker.options.title ?? "New Marker",
      description: p.description ?? "",
      image: p.image,
      mp4: p.mp4,
      locked: !!p.locked,
      links: Array.isArray(p.links) ? JSON.parse(JSON.stringify(p.links)) : []
    };
  }

  // Create a Leaflet marker + hook it up exactly like your loader does
  function createMarkerFromPoint(point, { openPopup = true } = {}) {
    const fullId = `${point.layer}:${point.id}`;

    const marker = L.marker(point.coords, {
      
      icon: createSvgMarker(point.category, false, point.icon, !!point.locked),
      title: point.name,
      draggable: window.GG_EDIT_MODE && !point.locked
    });

    marker.__dataRef = point;
    applyLockState(marker, !!point.locked);
    if (window.GG_EDIT_MODE) {

      const drag = ensureDragging(marker);
      if (drag) {
        if (marker.isLocked) drag.disable();
        else drag.enable();
      }
    }

    marker.on("dragend", () => {
      const pos = marker.getLatLng();
      point.coords = [pos.lat, pos.lng];
    });

    marker.category = point.category;
    marker.description = point.description;
    marker.links = point.links || [];
    marker.isFound = false;
    marker.mapLayer = point.layer || currentLayer;
    marker.__id = fullId;
    marker.iconKey = point.icon;
    marker.mp4 = point.mp4;
    marker.image = point.image;

    markers[fullId] = marker;

    if (marker.mapLayer === currentLayer) marker.addTo(map);

    createMarkerPopup(marker, fullId);
    attachRightClick(marker);
    updateMarkersByCategory();
    updateProgressDisplay();

    if (openPopup) marker.openPopup();

    return marker;
  }

  window.GG_ADD_MARKER_AT = function(latlng) {
    if (!window.GG_EDIT_MODE) return;

    // Don‚Äôt allow adding until the JSON has loaded,
    // because loadMarkers() will overwrite GG_MARKER_DATA.
    if (!didLoadMarkers || !Array.isArray(window.GG_MARKER_DATA) || window.GG_MARKER_DATA.length === 0) {
      window.GG_PENDING_ADD_LATLNGS = window.GG_PENDING_ADD_LATLNGS || [];
      window.GG_PENDING_ADD_LATLNGS.push(latlng);
      console.warn("Markers not loaded yet ‚Äî queued add.");
      return;
    }

    const layer = currentLayer;

    // Pick a unique id like new, new2, new3...
    const newId = makeUniqueId("new", layer) || makeUniqueId("m", layer);
    if (!newId) {
      alert("Couldn't generate a unique ID.");
      return;
    }

    const point = {
      id: newId,
      layer,
      coords: [latlng.lat, latlng.lng],
      category: "crystals",
      icon: "crystals",
      name: `New Marker (${newId})`
    };

    window.GG_MARKER_DATA.push(point);
    totalCount = window.GG_MARKER_DATA.length;

    createMarkerFromPoint(point, { openPopup: false });
  };

  window.pasteCopiedMarkerAt = function pasteCopiedMarkerAt(latlng) {
    if (!window.GG_EDIT_MODE) return;
    if (!window.GG_COPIED_MARKER) {
      alert("No copied marker yet. Open a marker popup and click Copy.");
      return;
    }

    const src = window.GG_COPIED_MARKER;
    const layer = currentLayer;

    // new id = oldId_copy (or oldId_copy2, oldId_copy3...)
    const baseWanted = `${String(src.id ?? "").trim()}_copy`;
    const newId = makeUniqueId(baseWanted, layer);
    if (!newId) {
      alert("Couldn't generate a unique ID.");
      return;
    }

    const point = {
      ...src,
      id: newId,
      layer,
      coords: [latlng.lat, latlng.lng]
    };

    if (!point.description) delete point.description;
    if (!point.image) delete point.image;
    if (!point.mp4) delete point.mp4;
    if (!point.links?.length) delete point.links;

    window.GG_MARKER_DATA.push(point);
    totalCount = window.GG_MARKER_DATA.length;

    createMarkerFromPoint(point, { openPopup: true });
  };

  // Editor pick-lists (must match your checkbox values for filtering)
  const GG_CATEGORY_OPTIONS = [
    { value: "crystals", label: "Crystals" },
    { value: "hearts",   label: "Hearts" },
    { value: "tapes",    label: "Cassettes" },
    { value: "keys",     label: "Keys/Locks" },
    { value: "walls",    label: "Smashable Walls" },
    { value: "NPC",      label: "NPCs" },
    { value: "secrets",  label: "Secrets" },
  ];

  // Icon options = keys from your SVG_ICONS object
  function getIconOptions() {
    try {
      return Object.keys(SVG_ICONS).map(k => ({ value: k, label: k }));
    } catch {
      return [];
    }
  }

  function normalizeMediaPath(input, defaultFolder) {
    const v = (input ?? "").trim();
    if (!v) return ""; // blank => remove
    // If user typed a URL or already provided a folder path, keep it
    if (v.startsWith("http://") || v.startsWith("https://") || v.startsWith("/") || v.includes("/")) return v;
    // Otherwise auto-prefix
    return `${defaultFolder.replace(/\/$/, "")}/${v}`;
  }

  // Apply edits to BOTH the Leaflet marker and the backing JSON object
  function applyEditsToMarker(marker, oldFullId, { id, name, category, iconKey, description, image, mp4, locked }) {
    if (!marker) return;

    const point = marker.__dataRef;
    if (!point) return;

    const layer = point.layer || marker.mapLayer || currentLayer;

    // ============================
    // ID CHANGE (safe re-key)
    // ============================
    let newFullId = oldFullId;

    if (typeof id === "string" && id.trim() && id.trim() !== point.id) {
      const cleanId = id.trim();

      if (cleanId.includes(":")) {
        alert("ID cannot contain ':'");
        return;
      }
      if (/\s/.test(cleanId)) {
        alert("ID cannot contain spaces");
        return;
      }

      const candidateFullId = `${layer}:${cleanId}`;

      if (markers[candidateFullId] || foundMarkers[candidateFullId]) {
        alert(`A marker with ID "${candidateFullId}" already exists.`);
        return;
      }

      // remove old key
      delete markers[oldFullId];
      delete foundMarkers[oldFullId];

      // update ids
      point.id = cleanId;
      marker.__id = candidateFullId;

      // re-add to correct bucket
      if (marker.isFound) foundMarkers[candidateFullId] = marker;
      else markers[candidateFullId] = marker;

      newFullId = candidateFullId;
    }

    // ============================
    // OTHER FIELDS
    // ============================
    if (typeof name === "string") {
      const n = name.trim() || "Untitled Marker";
      marker.options.title = n;
      point.name = n;
    }

    if (typeof category === "string") {
      marker.category = category;
      point.category = category;
    }

    if (typeof locked === "boolean") {
      marker.isLocked = locked;
      if (locked) point.locked = true;
      else delete point.locked; // keeps JSON clean if false

      applyLockState(marker, locked);
    }

    if (typeof iconKey === "string") {
      marker.iconKey = iconKey;
      point.icon = iconKey;
    }

    // Description (blank => remove)
    if (typeof description === "string") {
      const d = description.trim();
      marker.description = d;
      if (d) point.description = d;
      else delete point.description;
    }

    // Image (blank => remove, filename => images/<file>)
    if (typeof image === "string") {
      const imgPath = normalizeMediaPath(image, "images");
      marker.image = imgPath || null;
      if (imgPath) point.image = imgPath;
      else delete point.image;
    }

    // MP4/GIF (blank => remove, filename => gifs/<file>)
    if (typeof mp4 === "string") {
      const mp4Path = normalizeMediaPath(mp4, "gifs");
      marker.mp4 = mp4Path || null;
      if (mp4Path) point.mp4 = mp4Path;
      else delete point.mp4;
    }

    // Refresh the marker icon
    marker.setIcon(createSvgMarker(marker.category, marker.isFound, marker.iconKey, !!marker.isLocked));

    // Rebuild popup (so image/video sections appear/disappear)
    createMarkerPopup(marker, newFullId);

    updateMarkersByCategory();
  }

  function createMarkerPopup(marker, id) {
    const isFound = marker.isFound;

    // Create container div
    const popupContainer = document.createElement("div");
    popupContainer.style.fontFamily = "'Segoe UI', sans-serif";
    popupContainer.style.minWidth = "220px";
    popupContainer.style.color = "#fff";
    popupContainer.style.padding = "10px";

    // Title
    const title = document.createElement("h3");
    title.style.margin = "0 0 6px 0";
    title.style.fontSize = "20px";
    title.style.color = "#9c7cff";
    title.innerText = marker.options.title;
    popupContainer.appendChild(title);

    // Description
    if (marker.description) {
      const desc = document.createElement("p");
      desc.style.margin = "0 0 10px 0";
      desc.style.fontSize = "14px";
      desc.style.lineHeight = "1.4";
      desc.style.color = "#fff";
      desc.innerHTML = marker.description
        .replace(/\n/g, "<br>")
        .replace(/\*(.*?)\*/g, "<em>$1</em>");
      popupContainer.appendChild(desc);
    }

    // ============================
    // EDIT UI (only in ?edit=true)
    // ============================
    if (window.GG_EDIT_MODE) {
      const editWrap = document.createElement("div");
      editWrap.style.marginTop = "10px";
      editWrap.style.padding = "10px";
      editWrap.style.borderRadius = "8px";
      editWrap.style.background = "rgba(255,255,255,0.06)";
      editWrap.style.border = "1px solid rgba(255,255,255,0.10)";

      const editTitle = document.createElement("div");
      editTitle.innerText = "Edit Marker";
      editTitle.style.fontWeight = "700";
      editTitle.style.marginBottom = "8px";
      editTitle.style.fontSize = "14px";
      editTitle.style.color = "#fff";
      editWrap.appendChild(editTitle);

      // --- ID input ---
      const idLabel = document.createElement("div");
      idLabel.innerText = "ID";
      idLabel.style.fontSize = "12px";
      idLabel.style.opacity = "0.85";
      idLabel.style.marginBottom = "4px";
      editWrap.appendChild(idLabel);

      const idInput = document.createElement("input");
      idInput.type = "text";
      idInput.value = marker.__dataRef?.id || "";   // <-- current id
      idInput.placeholder = "e.g. c1 (no spaces, no :)";
      idInput.style.width = "100%";
      idInput.style.boxSizing = "border-box";
      idInput.style.padding = "8px";
      idInput.style.borderRadius = "8px";
      idInput.style.border = "none";
      idInput.style.outline = "none";
      idInput.style.marginBottom = "10px";
      idInput.style.background = "rgba(0,0,0,0.25)";
      idInput.style.color = "#fff";
      editWrap.appendChild(idInput);

      // --- Name input ---
      const nameLabel = document.createElement("div");
      nameLabel.innerText = "Name";
      nameLabel.style.fontSize = "12px";
      nameLabel.style.opacity = "0.85";
      nameLabel.style.marginBottom = "4px";
      editWrap.appendChild(nameLabel);

      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = marker.options.title || "";
      nameInput.placeholder = "Marker name...";
      nameInput.style.width = "100%";
      nameInput.style.boxSizing = "border-box";
      nameInput.style.padding = "8px";
      nameInput.style.borderRadius = "8px";
      nameInput.style.border = "none";
      nameInput.style.outline = "none";
      nameInput.style.marginBottom = "10px";
      nameInput.style.background = "rgba(0,0,0,0.25)";
      nameInput.style.color = "#fff";
      editWrap.appendChild(nameInput);

      // --- Category select ---
      const catLabel = document.createElement("div");
      catLabel.innerText = "Category";
      catLabel.style.fontSize = "12px";
      catLabel.style.opacity = "0.85";
      catLabel.style.marginBottom = "4px";
      editWrap.appendChild(catLabel);

      const catSelect = document.createElement("select");
      catSelect.style.width = "100%";
      catSelect.style.boxSizing = "border-box";
      catSelect.style.padding = "8px";
      catSelect.style.borderRadius = "8px";
      catSelect.style.border = "none";
      catSelect.style.outline = "none";
      catSelect.style.marginBottom = "10px";
      catSelect.style.background = "rgba(0,0,0,0.25)";
      catSelect.style.color = "#fff";

      GG_CATEGORY_OPTIONS.forEach(opt => {
        const o = document.createElement("option");
        o.value = opt.value;
        o.innerText = opt.label;
        catSelect.appendChild(o);
      });

      catSelect.value = marker.category || "crystals";
      editWrap.appendChild(catSelect);

      // --- Icon select ---
      const iconLabel = document.createElement("div");
      iconLabel.innerText = "Icon";
      iconLabel.style.fontSize = "12px";
      iconLabel.style.opacity = "0.85";
      iconLabel.style.marginBottom = "4px";
      editWrap.appendChild(iconLabel);

      const iconSelect = document.createElement("select");
      iconSelect.style.width = "100%";
      iconSelect.style.boxSizing = "border-box";
      iconSelect.style.padding = "8px";
      iconSelect.style.borderRadius = "8px";
      iconSelect.style.border = "none";
      iconSelect.style.outline = "none";
      iconSelect.style.marginBottom = "10px";
      iconSelect.style.background = "rgba(0,0,0,0.25)";
      iconSelect.style.color = "#fff";

      const iconOptions = getIconOptions();
      iconOptions.forEach(opt => {
        const o = document.createElement("option");
        o.value = opt.value;
        o.innerText = opt.label;
        iconSelect.appendChild(o);
      });

      iconSelect.value = marker.iconKey || marker.category || "crystals";
      editWrap.appendChild(iconSelect);

      // --- Description textarea ---
      const descLabel = document.createElement("div");
      descLabel.innerText = "Description";
      descLabel.style.fontSize = "12px";
      descLabel.style.opacity = "0.85";
      descLabel.style.marginBottom = "4px";
      editWrap.appendChild(descLabel);

      const descInput = document.createElement("textarea");
      descInput.value = marker.__dataRef?.description || "";
      descInput.placeholder = "Optional. Supports your *italics* formatting.";
      descInput.rows = 4;
      descInput.style.width = "100%";
      descInput.style.boxSizing = "border-box";
      descInput.style.padding = "8px";
      descInput.style.borderRadius = "8px";
      descInput.style.border = "none";
      descInput.style.outline = "none";
      descInput.style.marginBottom = "10px";
      descInput.style.resize = "vertical";
      descInput.style.background = "rgba(0,0,0,0.25)";
      descInput.style.color = "#fff";
      editWrap.appendChild(descInput);

      // --- Image filename/path ---
      const imgLabel = document.createElement("div");
      imgLabel.innerText = "Image (filename or path)";
      imgLabel.style.fontSize = "12px";
      imgLabel.style.opacity = "0.85";
      imgLabel.style.marginBottom = "4px";
      editWrap.appendChild(imgLabel);

      const imgInput = document.createElement("input");
      imgInput.type = "text";
      imgInput.value = marker.__dataRef?.image || "";
      imgInput.placeholder = "e.g. c1.jpg (auto => images/c1.jpg) or images/c1.jpg or https://...";
      imgInput.style.width = "100%";
      imgInput.style.boxSizing = "border-box";
      imgInput.style.padding = "8px";
      imgInput.style.borderRadius = "8px";
      imgInput.style.border = "none";
      imgInput.style.outline = "none";
      imgInput.style.marginBottom = "10px";
      imgInput.style.background = "rgba(0,0,0,0.25)";
      imgInput.style.color = "#fff";
      editWrap.appendChild(imgInput);

      // --- GIF/MP4 filename/path ---
      const mp4Label = document.createElement("div");
      mp4Label.innerText = "GIF/MP4 (filename or path)";
      mp4Label.style.fontSize = "12px";
      mp4Label.style.opacity = "0.85";
      mp4Label.style.marginBottom = "4px";
      editWrap.appendChild(mp4Label);

      const mp4Input = document.createElement("input");
      mp4Input.type = "text";
      mp4Input.value = marker.__dataRef?.mp4 || "";
      mp4Input.placeholder = "e.g. clip1.mp4 (auto => gifs/clip1.mp4) or gifs/clip1.mp4 or https://...";
      mp4Input.style.width = "100%";
      mp4Input.style.boxSizing = "border-box";
      mp4Input.style.padding = "8px";
      mp4Input.style.borderRadius = "8px";
      mp4Input.style.border = "none";
      mp4Input.style.outline = "none";
      mp4Input.style.marginBottom = "10px";
      mp4Input.style.background = "rgba(0,0,0,0.25)";
      mp4Input.style.color = "#fff";
      editWrap.appendChild(mp4Input);

      // --- Lock toggle (disable dragging) ---
      const lockRow = document.createElement("label");
      lockRow.className = "popup-toggle";
      lockRow.style.marginTop = "6px";
      lockRow.innerText = "Lock (disable drag) ";

      const lockInput = document.createElement("input");
      lockInput.type = "checkbox";
      lockInput.checked = !!(marker.__dataRef?.locked);

      lockInput.addEventListener("change", () => {
        const locked = lockInput.checked;

        // Update JSON cleanly
        if (marker.__dataRef) {
          if (locked) marker.__dataRef.locked = true;
          else delete marker.__dataRef.locked;
        }

        // Apply lock state + dragging config
        applyLockState(marker, locked);

        // Refresh icon (red outline only in edit mode)
        marker.setIcon(createSvgMarker(marker.category, marker.isFound, marker.iconKey, locked));
      });

      lockRow.appendChild(lockInput);
      editWrap.appendChild(lockRow);

      // --- Copy + Paste row ---
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.gap = "8px";
      row.style.marginBottom = "10px";

      const copyBtn = document.createElement("button");
      copyBtn.innerText = "Copy Marker";
      copyBtn.style.flex = "1";
      copyBtn.style.padding = "10px";
      copyBtn.style.borderRadius = "10px";
      copyBtn.style.border = "none";
      copyBtn.style.cursor = "pointer";
      copyBtn.style.fontWeight = "700";
      copyBtn.style.background = "rgba(255,255,255,0.12)";
      copyBtn.style.color = "white";

      copyBtn.onclick = () => {
        window.GG_COPIED_MARKER = clonePointTemplateFromMarker(marker);
        alert(`Copied "${marker.options.title}" (id: ${marker.__dataRef?.id})\nClick map to paste.`);
      };

      const pasteBtn = document.createElement("button");
      pasteBtn.innerText = "Paste Here";
      pasteBtn.style.flex = "1";
      pasteBtn.style.padding = "10px";
      pasteBtn.style.borderRadius = "10px";
      pasteBtn.style.border = "none";
      pasteBtn.style.cursor = "pointer";
      pasteBtn.style.fontWeight = "700";
      pasteBtn.style.background = "rgba(255,255,255,0.12)";
      pasteBtn.style.color = "white";

      pasteBtn.onclick = () => {
        // paste near the current marker (slight offset so it doesn't stack perfectly)
        const ll = marker.getLatLng();
        window.pasteCopiedMarkerAt({ lat: ll.lat + 0.2, lng: ll.lng + 0.2 });
      };

      row.appendChild(copyBtn);
      row.appendChild(pasteBtn);
      editWrap.appendChild(row);
    
      // --- Delete button ---
      const deleteBtn = document.createElement("button");
      deleteBtn.innerText = "Delete Marker";
      deleteBtn.style.width = "100%";
      deleteBtn.style.padding = "10px";
      deleteBtn.style.borderRadius = "10px";
      deleteBtn.style.border = "none";
      deleteBtn.style.cursor = "pointer";
      deleteBtn.style.fontWeight = "800";
      deleteBtn.style.background = "#e53935";
      deleteBtn.style.color = "white";
      deleteBtn.style.marginTop = "8px";

      deleteBtn.onclick = () => {
        if (!confirm(`Delete this marker?\n\n${id}`)) return;
        deleteMarkerEverywhere(id);
      };

      editWrap.appendChild(deleteBtn);

      // --- Save button ---
      const saveBtn = document.createElement("button");
      saveBtn.innerText = "Save Edits";
      saveBtn.style.width = "100%";
      saveBtn.style.padding = "10px";
      saveBtn.style.borderRadius = "10px";
      saveBtn.style.border = "none";
      saveBtn.style.cursor = "pointer";
      saveBtn.style.fontWeight = "700";
      saveBtn.style.background = "#673ab7";
      saveBtn.style.color = "white";

      saveBtn.addEventListener("click", (e) => {
        // Prevent Leaflet/map from treating this as a map click / marker click
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        // Leaflet helper (extra-safe)
        if (window.L && L.DomEvent) L.DomEvent.stop(e);

        applyEditsToMarker(marker, id, {
          id: idInput.value.trim(),
          name: nameInput.value.trim(),
          category: catSelect.value,
          iconKey: iconSelect.value,
          description: descInput.value,
          image: imgInput.value,
          locked: lockInput.checked,
          mp4: mp4Input.value,
        });

        // Close the currently open popup (most reliable)
        setTimeout(() => {
          map.closePopup();
          // optional: also ensure the marker‚Äôs popup closes
          marker.closePopup();
        }, 0);
      });

      editWrap.appendChild(saveBtn);
      popupContainer.appendChild(editWrap);
    }

    if (marker.image) {
      const img = document.createElement("img");
      img.src = marker.image;
      img.alt = marker.options.title || "";
      img.loading = "lazy";

      img.style.width = "100%";
      img.style.marginTop = "8px";
      img.style.borderRadius = "6px";
      img.style.display = "block";

      popupContainer.appendChild(img);
    }

    if (marker.mp4) {
      const video = document.createElement("video");
      video.dataset.src = marker.mp4;   // üëà lazy-load
      video.muted = true;
      video.loop = true;
      video.playsInline = true;
      video.preload = "none";            // üëà important

      video.style.width = "100%";
      video.style.marginTop = "8px";
      video.style.borderRadius = "6px";
      video.style.display = "block";

      popupContainer.appendChild(video);

      // Load + play ONLY when popup opens
      marker.on("popupopen", () => {
        if (!video.src) {
          video.src = video.dataset.src;
          video.load();
        }
        video.play().catch(() => {});
      });

      // Pause when popup closes
      marker.on("popupclose", () => {
        video.pause();
      });
    }

    if (marker.links.length > 0) {
      const linkHeader = document.createElement("div");
      linkHeader.style.fontSize = "13px";
      linkHeader.style.marginBottom = "6px";
      linkHeader.style.opacity = "0.8";
      linkHeader.innerText = "Related:";
      popupContainer.appendChild(linkHeader);

      marker.links.forEach(link => {
        const a = document.createElement("div");
        a.innerText = "‚ûú " + link.label;
        a.style.cursor = "pointer";
        a.style.color = "#9c7cff";
        a.style.fontSize = "14px";
        a.style.marginBottom = "4px";
        a.style.textDecoration = "underline";

        a.onclick = () => jumpToMarker(link.target, link.zoom);

        popupContainer.appendChild(a);
      });
    }

    // Horizontal line
    const hr = document.createElement("hr");
    hr.style.border = "none";
    hr.style.borderTop = "1px solid rgba(255,255,255,0.1)";
    hr.style.margin = "6px 0";
    popupContainer.appendChild(hr);

    // Found checkbox
    const label = document.createElement("label");
    label.className = "popup-toggle";
    label.innerText = "Found ";

    const input = document.createElement("input");
    input.type = "checkbox";
    input.checked = isFound;
    input.addEventListener("change", e => toggleFound(marker.__id, e.target));

    label.appendChild(input);
    popupContainer.appendChild(label);

    // Bind popup
    marker.unbindPopup();
    marker.bindPopup(popupContainer, {
      maxWidth: 520,
      minWidth: 420,
      className: "popup-dark"
    });

    marker.on('popupopen', e => {
      const container = e.popup._container;
      if (container) container.classList.add('popup-dark');
    });

    marker.on("popupclose", () => {
      const video = popupContainer.querySelector("video");
      if (video) video.pause();
    });

    marker.on("popupopen", () => {
      if (window.GG_EDIT_MODE) window.GG_SELECTED_MARKER = marker;
    });
  }

  document.getElementById('resetProgress').onclick = async () => {
  if (!confirm("Are you sure you want to reset all progress?")) return;

  // Clear localStorage
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith("found_")) localStorage.removeItem(key);
  });

  // Reset all found markers
  for (const id in foundMarkers) {
    const marker = foundMarkers[id];

    marker.isFound = false; // ‚úÖ CRITICAL FIX
    marker.setIcon(createSvgMarker(marker.category, false, marker.iconKey, !!marker.isLocked));

    markers[id] = marker;
  }

  // Clear foundMarkers object
  Object.keys(foundMarkers).forEach(id => delete foundMarkers[id]);

  updateMarkersByCategory();
  updateProgressDisplay();

  // Reset Firebase if logged in
  if (isLoggedIn && auth.currentUser) {
    try {
      const ref = doc(db, "users", auth.currentUser.uid, "progress", "foundMarkers");
      await setDoc(ref, { found: [] });
    } catch (err) {
      console.error("Firebase reset failed:", err);
    }
  }

  // Rebuild popups so checkbox reflects reset state
    Object.values(markers).forEach(marker => {
    createMarkerPopup(marker, marker.__id);
    });
};

</script>

</body>
</html>
